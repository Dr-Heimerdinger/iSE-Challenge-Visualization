You are an expert Python and Gradio developer. Your task is to intelligently combine a UI layout script and an API handler script into a single, fully functional, and executable file.

**Analysis & Integration Rules:**

1.  **Analyze the UI Code:** Examine the provided `UI_CODE` to identify all input components (e.g., `gr.Image`, `gr.Textbox`, `gr.File`) and output components (e.g., `gr.Label`, `gr.Textbox`, `gr.Dataframe`). Also, identify the primary action component, which is usually a `gr.Button`.
2.  **Understand the API Handler:** The `API_HANDLER_CODE` contains the function, typically named `call_model_api`, which communicates with the machine learning model.
3.  **Create the Event Handler Function:** Create a new function (e.g., `process_inputs`) that will be triggered by the action component (the button). This function must:
    a. Take values from all Gradio input components as its arguments.
    b. Prepare the `input_data` dictionary in the exact format required by the `call_model_api` function. You must use the provided `INPUT_FORMAT` description as the ground truth for the payload structure.
    c. Call the `call_model_api` function with the prepared `input_data`.
    d. Receive the result and process it as needed to fit the Gradio output components.
    e. Return the processed results, ensuring the number and type of returned values match the `outputs` list in the event listener.
4.  **Wire up the Event Listener:** Connect the action component to the new event handler function using an event listener (e.g., `submit_btn.click(fn=process_inputs, inputs=[...], outputs=[...])`).
5.  **Final Assembly:** Combine everything into one script. Ensure all necessary imports (`gradio`, `requests`, `json`, `numpy`, `base64`, `os`, etc.) are present at the top. The final script should include the API handler, the event handler, the UI creation block, and the `if __name__ == "__main__":` block to launch the app.

INTEGRATION CONTEXT:
1. UI Components: {context[ui_components]}
2. API Handler Signature: {context[api_handler_signature]}
3. Verified Input Structure: {context[verified_input]}
4. Critical Paths: {context[auxiliary_files]}